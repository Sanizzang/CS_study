<details>
<summary>라이브러리와 프레임워크의 차이가 뭔가요?</summary>
<div markdown="1">
라이브러리와 프레임워크의 주요 차이는 제어 흐름에 대한 주도성이 누구에게 / 어디에게 있는가에 있습니다. 라이브러리는 개발자가 필요할 때 호출하여 사용할 수 있는 도구 모음이며, 개발자는 라이브러리의 사용 여부를 자유롭게 결정할 수 있습니다. 반면에 프레임워크는 개발자가 프레임워크가 제공하는 규칙과 구조를 따라 개발해야 합니다.
</div>
</details>

<details>
<summary>디자인 패턴이 뭔가요?</summary>
<div markdown="1">
디자인 패턴은 소프트웨어 개발에서 자주 발생하는 문제를 해결하기 위한 일종의 설계 템플릿 입니다. 주로 생성, 구조, 행동 등 세 가지 카테고리로 나뉩니다.
</div>
</details>

<details>
<summary>싱글톤 패턴이 뭔가요?</summary>
<div markdown="1">
싱글톤 패턴은 한 클래스가 오직 하나의 인스턴스만을 가지도록 하는 디자인 패턴입니다. 주로 데이터베이스 연결, 로깅, 캐시 등에서 활용되며, 메모리 효율성과 속도 측면에서 이점이 있습니다.
</div>
</details>

<details>
<summary>의존성 주입이 뭔가요?</summary>
<div markdown="1">
의존성 주입은 객체 지향 프로그래밍에서 한 객체가 다른 객체에 의존하는 관계를 만들 떄, 의존성을 외부에서 주입하여 객체 간의 결합도를 낮추는 디자인 패턴입니다. 이를 통해 코드의 유연성과 재사용성을 향상시킬 수 있습니다. 객체가 직접 의존하는 객체를 생성하는 것이 아니라 외부에서 의존성을 주입받아 사용하게 되므로, 객체 간의 결합도를 낮추고 테스트 용이성을 높일 수 있습니다.
</div>
</details>

<details>
<summary>팩토리 패턴이 뭔가요?</summary>
<div markdown="1">
팩토리 패턴은 객체 생성을 캡슐화하여 클라이언트에게 클래스의 인턴스를 생성할지 결정하는 디자인 패턴입니다. 이 패턴을 사용하면 클라이언트가 직접 객체를 생성하는 대신 팩토리 메서드나 팩토리 클래스를 통해 객체를 생성할 수 있습니다. 팩토리 패턴은 주로 객체 생성 로직이 복잡하거나 여러 종류의 객체를 생성해야 할 때 사용됩니다.
</div>
</details>

<details>
<summary>전략 패턴이 뭔가요?</summary>
<div markdown="1">
전략 패턴은 알고리즘군을 정의하고 각각을 캡슐화하여 교환 가능하게 만드는 패턴입니다. 이 패턴을 사용하면 동일한 문제를 해결하는 다양한 알고리즘을 정의하고, 실행 시에 필요한 알고리즘을 선택하여 사용할 수 있습니다.
</div>
</details>

<details>
<summary>옵저버 패턴이 뭔가요?</summary>
<div markdown="1">
옵저버 패턴은 한 객체의 상태 변화를 관찰하고, 이에 따라 다른 객체들이 자동으로 업데이트 되는 디자인 패턴입니다.  예를 들어, 주식 가격 변동을 감시하는 시스템에서는 주식 시장이 주체가 되고, 각 주식 거래자가 옵저버가 될 수 있습니다. 주식 시장의 가격이 변동되면, 이를 관찰하고 있는 각 거래자에게 자동으로 알림을 전달하여 업데이트를 수행하게 됩니다. 
</div>
</details>

<details>
<summary>상속과 구현의 차이가 뭔가요?</summary>
<div markdown="1">
상속은 자식 클래스가 부모 클래스의 메서드 등을 상속받아 사용하며 자식 클래스에서 추가 및 확장을 할 수 있는 것을 말합니다. 구현은 부모 인터페이스를 자식 클래스에서 재정의하여 구현하는 것을 말하며, 상속과는 달리 반드시 부모 클래스의 메서드를 재정의하여 구현해야 합니다.
</div>
</details>

<details>
<summary>프록시 패턴이 뭔가요?</summary>
<div markdown="1">
프록시 패턴은 한 객체에 대한 접근을 제어하고 싶을 떄 사용됩니다. 프록시는 실제 객체에 대한 대리자 역할을 하며, 클라이언트가 프록시 객체를 통해 실제 객체에 접근하게 됩니다. 이를 통해 추가적인 작업을 수행하거나, 실제 객체에 대한 접근을 제한하거나, 비용이 많이 드는 작업의 결과를 캐싱할 수 있습니다.
</div>
</details>

<details>
<summary>CDN이 뭔가요?</summary>
<div markdown="1">
 전 세계에 분산된 서버 네트워크를 통해 웹 콘텐츠를 빠르게 전송하는 기술입니다. 이를 통해 웹 사이트의 성능을 향상시키고, 로딩 시간을 줄이며, 대역폭 사용량을 줄여 사용자 경험을 최적화합니다. CDN은 주로 정적 파일(이미지, 스크립트, 스타일 시트 등)을 제공하는 데 사용되며, 대규모 웹 사이트나 콘텐츠를 제공하는 회사에서 널리 사용됩니다.
</div>
</details>

<details>
<summary>CORS가 뭔가요?</summary>
<div markdown="1">
CORS는 서버가 웹 브라우저에서 리소스를 로드할 때 다른 오리진을 통해 로드하지 못하게 하는 HTTP 헤더 기반 메커니즘입니다.

프런트엔드 개발 시 프런트엔드 서버를 만들어서 백엔드 서버와 통신할 때 주로 CORS 에러를 마주치는데, 이를 해결하기 위해 프런트엔드에서 프록시 서브를 만들기도 합니다.
</div>
</details>

<details>
<summary>이티레이터 패턴이 뭔가요?</summary>
<div markdown="1">
이터레이터 패턴은 객체의 컬렉션을 순차적으로 접근할 수 있는 방법을 제공하는 디자인 패턴입니다. 이를 통해 컬렉션 내부 구조에 상관없이 요소에 접근할 수 있습니다. 
</div>
</details>

<details>
<summary>MVC 패턴이 뭔가요?</summary>
<div markdown="1">
MVC 패턴은 Model-View-Controller의 약자로, 소프트웨어를 세 가지 요소로 구성하는 디자인 패턴입니다. Model은 데이터와 비즈니스 로직을 담당하고, View는 사용자 인터페이스를 표현하며, Controller는 사용자 입력을 처리하고 Model과 View를 연결하는 역할을 합니다. 이를 통해 소프트웨어를 모듈화하고 유지보수성을 향상시키는 데 도움이 됩니다.
</div>
</details>

<details>
<summary>객체지향 프로그래밍이 뭔가요?</summary>
<div markdown="1">
객체들의 집합으로 프로그램의 상호 작용을 표현하며 데이터를 객체로 취급하여 객체 내부에 선언된 메서드를 활용하는 방식을 말합니다.
</div>
</details>

<details>
<summary>객체지향 프로그래밍의 특징을 설명해주세요</summary>
<div markdown="1">
객체지향 프로그래밍의 특징으로는 캡슐화, 상속, 다형성, 추상화 등이 있습니다. 

캡슐화는 객체의 속성과 메서드를 하나로 묶고 일부를 외부에 감추어 은닉하는 것을 말합니다. 이를 통해 데이터를 보호하고 외부에서 직접 접근하지 못하도록 합니다.

상속은 부모 클래스의 특성을 자식 클래스가 물려 받아 재사용할 수 있습니다. 이를 통해 코드의 재사용성과 확장성을 높입니다.

다형성은 하나의 메서드나 클래스가 다양한 방법으로 동작하는 것을 말합니다. 대표적으로 오버로딩, 오버라이딩이 있습니다.

추상화는 객체의 중요한 특징을 강조하고 세부 사항을 숨김으로써 복잡성을 관리할 수 있습니다. 이를 통해 코드의 이해와 관리가 용이해집니다.
</div>
</details>

<details>
<summary>오버로딩, 오버라이딩에 대해 설명해주세요</summary>
<div markdown="1">
변수의 유형, 개수 등으로 여러 개를 둘 수 있으며 컴파일 중에 발생하는 ‘정적’ 다형성입니다.

오버라이딩은 주로 메서드 오버라이딩을 말하며 상위 클래스로부터 상속받은 메서드를 하위 클래스가 재정의하는 것을 의미합니다. 이는 런타임 중에 발생하는 ‘동적’다형성입니다.
</div>
</details>

<details>
<summary>SOLID에 대해서 설명해주세요</summary>
<div markdown="1">
첫 번째로, 단일 책임 원칙은 모든 클래스는 각각 하나의 책임을 가져야 합니다.

두 번째로, 개방 폐쇄 원칙은 확장에는 열려있고 수정에는 닫혀있는 것으로, 기능을 추가할 때는 기존의 코드를 변경하지 않고도 추가할 수 있어야 합니다.

세 번째는, 리스코프 치환 원칙으로 자식 클래스는 언제나 부모클래스를 대체할 수 있도록 상속되어야 합니다.

네 번째는, 인터페이스 분리 원칙으로 하나의 일반적인 인터페이스 보다는 여러개의 구체적인 인터페이스를 사용하는 것이 좋습니다. 

마지막으로, 의존역전의 원칙으로 의존관계를 맺을 때 즉 다른 것을 가져다 쓸 때는 좀 더 추상화된 것에 의존하는 것이 좋다는 것입니다.
</div>
</details>